\section{Motivation}
\label{s:motivation}

% - characteristics of concurrency bugs
% - challenges / design requirements
% - limitations of existing approaches

This work is motivated by the observation that concurrency fuzzing
requires new interleaving coverage metric and better exploration
scheme.  In this section, we first study how concurrency bugs manifest
depending on thread interleaving through a real-world concurrency bug
example.
%
From the study, we elicit design goals to effectively discover concurrency
bugs in the kernel, and discuss why existing approaches have limitations 
in satisfying the design goals.

%None of previous work properly addresses characteristics of \textit{offending thread interleaving} (\ie, one that causes a concurrency bug).
%
%As a consequence, previous work either \textbf{1)} disregards a
%multi-thread input in which a concurrency bug reside~\cite{krace,
  %conzzer},
%or \textbf{2)} waste the computing power by ineffectively exploring
%the search space of thread interleaving~\cite{snowboard, razzer, muzz}.

\PP{Manifestation of concurrency bugs}
%
\begin{figure}[t]
  \centering
  \includegraphics[width=0.85\linewidth]{fig/cve-2017-10661.pdf}
  \caption{Simplified code snippet of CVE-2017-17712. If \texttt{B1}
    is executed between \texttt{A2} and \texttt{A4}, concurrenct
    accesses on \texttt{inet->hdrincl} leads to uninitialized stack
    pointer usage on \texttt{rfv}, and an attacker may gain root
    privileges through a dedicated attack
    technique~\cite{stackspray}.}
  \label{fig:cve-2017-17712}
\end{figure}
%
In \autoref{fig:cve-2017-17712}, an uninitialized access bug may
manifest when two system calls are executed concurrently:
\texttt{sendmsg()} to send a message through an ipv4 socket, and
\texttt{setsockopt()} to modify an option of the ipv4 socket.

Let us assume \texttt{inet->hdrincl} is initially \texttt{1}.
%
During sending a message through the ipv4 socket, thread~A reads a
value of \texttt{inet->hdrincl} twice at \texttt{A2} and \texttt{A4}.
%
However, since these two read operations are not atomically executed,
thread~B may intervene in the middle of these two read operations.
%
In that case, if \texttt{B1} is executed between \texttt{A2} and
\texttt{A4}, thread~A reads different values of \texttt{inet->hdrincl}
at \texttt{A2} and \texttt{A4}, and dereference \texttt{rfv} without
initializing it at \texttt{A4}.


\PP{Observation 1: Combined interleaving orders}
%
This example demonstrates that a concurrency bug is caused by
\textit{a combined result of multiple interleaving orders}\footnote{A
  interleaving order denotes the execution order between a pair of
  instructions that access the same memory object.}.
%
In the example of \autoref{fig:cve-2017-17712}, two interleaving orders
are combined, which eventually causes the uninitialized access bug.
%
First, \texttt{A2} should be executed before \texttt{B1} (\ie,
$\texttt{A2} \Rightarrow \texttt{B1}$\footnote{In this paper,
  $\texttt{X} \Rightarrow \texttt{Y}$ denotes that \texttt{X} is
  executed before \texttt{Y}}) to make thread~A not initialize
\texttt{rfv}.
%
Second, \texttt{B1} should be executed before \texttt{A4} (\ie,
$\texttt{B1} \Rightarrow \texttt{A4}$) to make thread~A dereference
uninitialized \texttt{rfv} while other instructions do not contribute
to the bug.
%
%Therefore, thread interleavings satisfying a combination of the two
%interleaving orders (\ie,
%$(\texttt{A2} \Rightarrow \texttt{B1}) \wedge (\texttt{B1} \Rightarrow
%\texttt{A4}))$ cause the uninitialized access bug, while all other
%thread interleavings do not.
Therefore, to trigger the kernel concurrency bug, a fuzzer must
consider a combination of multiple interleaving orders. \eg, 
$(\texttt{A2} \Rightarrow \texttt{B1}) \wedge (\texttt{B1} \Rightarrow
\texttt{A4}))$ in \autoref{fig:cve-2017-17712}.


\PP{Design goal 1: Informative interleaving coverage} The observation
gives an insight of how to define interleaving coverage metric.  To
discover the uninitialized access bug, an interleaving coverage metric
should distinguish combinations of multiple interleaving orders.
%
For example,
$(\texttt{B1} \Rightarrow \texttt{A2}) \wedge (\texttt{B1} \Rightarrow
\texttt{A4})$ (\ie, \autoref{fig:alias-coverage}-(a)) and
$(\texttt{A2} \Rightarrow \texttt{B1}) \wedge (\texttt{B1} \Rightarrow
\texttt{A4})$ (\ie, \autoref{fig:alias-coverage}-(b)) should be
distinguished, and thus, interleaving coverage should not be saturated
until
$(\texttt{A2} \Rightarrow \texttt{B1}) \wedge (\texttt{B1} \Rightarrow
\texttt{A4})$ is executed.
%
Otherwise, a fuzzer may think that there is no more interesting thread
interleaving in the multi-thread input, and stop searching for new
thread interleavings of the multi-thread input, missing the
uninitialized access bug.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.8\linewidth]{fig/alias-coverage.pdf}
  \caption{Two thread interleavings between thread~A and thread~B
    described in \autoref{fig:cve-2017-17712}.
    %
    The uninitialized access bug manifests only in
    \texttt{Interleaving \#2}.
    %
    We intentionally omits bug-irrelevant memory accesses (\ie,
    \texttt{A6} and \texttt{B2}).}
  \label{fig:alias-coverage}
\end{figure}


\PP{Observation 2: Feedback from explored executions}
%
We find that even if an explored execution does not cause 
a concurrency bug, it provides useful feedback 
to guide what interleavings should be further explored.

In the example of \autoref{fig:cve-2017-17712}, let us assume a fuzzer
executes the two system calls \textit{sequentially} such that thread~B
executes all instructions followed by the execution of thread~A (\ie,
\autoref{fig:alias-coverage}-(a)).  In the explored execution, a
fuzzer observes the three instructions, \texttt{B1}, \texttt{A2}, and
\texttt{A4}, are executed in the order of
($\texttt{B1} \Rightarrow \texttt{A2} \Rightarrow \texttt{A4}$) and
they access the same memory object~(\ie, \texttt{inet->hdrincl}).
% \yj{can a fuzzer know they are conflicting instructions?}
%
This execution orders do not cause the uninitialized access bug.
%
However, from the explored execution, one can easily imagine a new
interleaving of these three instructions by changing the execution
order of \texttt{B1} and \texttt{A2}, resulting in
\autoref{fig:alias-coverage}-(b).
% $\texttt{A2} \Rightarrow \texttt{B1} \Rightarrow \texttt{A4}$).
%
The speculative interleaving is what exactly we are looking for; it
satisfies the combination of interleaving orders
$(\texttt{A2} \Rightarrow \texttt{B1}) \wedge (\texttt{B1} \Rightarrow
\texttt{A4}))$, and, if executed, the interleaving triggers the
uninitialized access bug.

\PP{Design goal 2: Coverage-based interleaving exploration scheme}
%
The observation gives a direction that how a fuzzer should explore 
the search space using a coverage metric.
If interleaving coverage tracks that
$\texttt{B1} \Rightarrow \texttt{A2} \Rightarrow \texttt{A4}$ is
\textit{explored} before, a fuzzer can utilize interleaving
coverage as feedback to infer \textit{unexplored} thread interleavings (\eg,
$\texttt{A2} \Rightarrow \texttt{B1} \Rightarrow \texttt{A4}$).
%
This allows a systematic way to explore the search space rather than
performing randomized exploration pervasively used in previous
approaches~\cite{ski, krace, pctalgorithm, muzz}.
% \yj{cite}
%
\blue{
  %
  Considering a concurrency bugs often manifest with a thread
  interleaving that rarely happen, the systematic interleaving
  exploration boosts up the concurrency bug discovery, as it directs
  the fuzzer to execute unexplored thread interleaving instead of
  executing random thread interleavings thousands of times.
  %
}

In summary, using the coverage metric expressing combinations of
interleaving orders and the coverage-based exploration scheme, a
fuzzer can effectively determine what to execute in future iterations,
and quickly discover concurrency bugs without redundantly executing
thread interleavings.

\subsection{Limitation of prior approaches}
\label{ss:existingapproaches}
%
% \begin{table}[t]
%   \centering
%   \input{table/motivation.tex}
%   \caption{Interleaving coverage metrics and interleaving search
%     strategy of recent concurrency fuzzing. ``--'' indicates that a
%     fuzzer does not adopt a concurrency coverage metric. \dr{TODO:
%       rewording}}
%   \label{table:motivation}
% \end{table}

% \autoref{table:motivation} summarizes interleaving coverage metrics and 
% interleaving search strategies of prior approaches.
%
Altough prior approaches achieve their own successes, we find that
their interleaving coverage metrics and interleaving exploration
scheme do not satisfy \textbf{Design goal 1} and \textbf{2}.


\PP{Less informative interleaving coverage}
%
We find that previously proposed interleaving coverage metrics are
less-informative because none of them consider a combination of
interleaving orders.


For example, let us suppose we adopt alias coverage~\cite{krace},
which tracks interleaving orders of a \textit{single} instruction
pair.
%
Alias coverage determines a thread interleaving \texttt{X} exposes a
unique behavior if \texttt{X} contains an unexplored
\blue{directed-instruction pair} $I_W \rightarrow I_R$, where $I_R$
reads a value written by $I_W$ and they are executed by different
threads.  \autoref{fig:alias-coverage} illustrates the simplified
explanation of why alias coverage does not satisfy the \textbf{Design
  goal 1}.
%
Assuming \texttt{Interleaving \#1} is executed first, alias coverage
identifies \texttt{Interleaving \#1} exposes unique behaviors when it
sees two unexplored directed-instruction pair:
($\texttt{B1} \rightarrow \texttt{A2}$) and
($\texttt{B1} \rightarrow \texttt{A4}$).
%
% The \texttt{Interleaving \#2} is the interleaving orders causing the bug.
However, according to alias coverage, \texttt{Interleaving \#2}, which
causes the uninitialized access bug, does not contain any new coverage
because ($\texttt{B1} \rightarrow \texttt{A4}$) is already explored in
\texttt{Interleaving \#1}.
% Krace considers that growing alias coverage is a promising signal 
% to explore thread interleavings further, but the \texttt{Interleaving \#2} does not increase alias coverage in this scenario.
%But, when alias coverage faces \texttt{Interleaving \#2} after
%\texttt{Interleaving \#1}, it suffers from locating unobserved unique
%behaviors of \texttt{Interleaving \#2}, because there is no unobserved
%interleaving order in \texttt{Interleaving \#2} (\ie,
%($\texttt{B1} \Rightarrow \texttt{A4}$) is already observed in
%\texttt{Interleaving \#1}).
%
Therefore, alias coverage may make the wrong decision about whether a
fuzzer needs to run these two system calls more, misleading a fuzzer
to de-prioritize a multi-thread input in which a concurrency bug
resides and switch to other inputs. In evaluation, we quantify the
limitation in \autoref{table:comparison-interleaving-search}.

\dr{I want to cut concurrenct call pair}
Likewise, concurrent call pair~\cite{conzzer} coverage also suffers from
distinguishing these two thread interleavings.
%
While concurrent call pair tracks a concurrently-executed function
pair, it is not aware of the fine-grained orders of instruction interleavings within a function.
%
Since two thread interleavings in \autoref{fig:alias-coverage} take
place in the same function (\ie, \texttt{A2} and \texttt{A4} are
executed in the same function), concurrent call pair is also limited
in distinguishing the two interleavings, and shows the same limitation
as alias coverage when it comes to discovering this uninitialized
access bug.

% is also saturated with these two thread
% interleavings, because once two functions \texttt{sendmsg()} and
% \texttt{setsockop()} are executed concurrently, concurrnet call pair
% does not matter how a thread interleaving occurs within the function
% pair.





% \yj{This paragraph must be easy enough for reader to intuitively understand, but hard to digest discussions}
% However, they are not applicable to track behavioral changes\yj{what does it mean?} according
% to a combination of interleaving orders, mainly because they either
% track only a \textit{single} interleaving order~\cite{krace, muzz} or
% \textit{coarse-grained information} such as a pair of two
% concurrently-executed functions~\cite{conzzer}.
% \yj{I do not understand why tracking a single int. order and coarse-grain information are not able to track behavioral changes}

% Taking the example of KRace's alias coverage,
% \autoref{fig:alias-coverage} describes two thread interleavings that
% saturate alias coverage found between two system calls in
% \autoref{fig:cve-2017-17712}.
% %
% In these example interleaving scenarios, the uninitialized access does
% not manifest even after alias coverage is saturated, and a fuzzer may
% decide to stop searching for new thread interleavings in the two
% system calls.
% %
% While we do not enumerate all proposed interleaving coverage metrics
% here, we find that they all share the same limitation.


\PP{Ineffective interleaving exploration scheme}
%
Stemming from the aforementioned limitations in coverage, 
proposed interleaving search strategies do not efficiently 
explore the search space guided by their interleaving coverage,
not satisfying \textbf{Design goal 2}.

Razzer~\cite{razzer} and Snowboard~\cite{snowboard} are coverage-oblivious.
They do not make use of any interleaving coverage 
and perform their randomized interleaving exploration.
%
Krace~\cite{krace} also explores thread interleavings randomly without
considering what thread interleavings are explored before.  Krace
limitedly utilizes interleaving coverage only when deciding whether it
runs a given multi-thread input more. Whereas, we use the coverage to
infer which thread interleavings to search further in future
iterations.
%
Conzzer~\cite{conzzer} is the only work that attempts to direct a
fuzzer based on interleaving coverage, but as discussed,  
it's interleaving coverage metric, concurrent call pair, does not capture instruction-level interleavings orders, missing important 
search guidelines.
%
As a consequence, existing approaches do not systematically search for
thread interleavings.  Rather, they \textit{blindly} go through
trial and error, exploring thread interleavings ineffectively .

% making \textit{redundant executions} without exploring
% meaningful thread interleavings\yj{Do we measure this?}.

% %
% However, its interleaving coverage (\ie, concurrent call pair) tracks
% thread interleavings in the function-level granularity, and is limited
% in distinguishing tested interleavings and untested interleavings in
% the instruction-level granularity.
% %
% In other words, the Conzzer's interleaving search strategy can direct
% a fuzzer to execute two functions \texttt{raw_sendmsg()} and
% \texttt{do_ip_setsockopt()} concurrently.
% %
% But even after that, Conzzer suffers from triggering the uninitialized
% bug since it is not aware of the execution order of instructions.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
