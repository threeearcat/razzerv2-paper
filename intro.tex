\section{Introduction}
\label{s:intro}

\dr{TODO: term consistency: interleaving order <-> interleaved instruction}

Multi-core era, many techniques are integrated in kernel to improve performance. 

The consequence of kernel concurrency bugs is disastrous. They crash
the entire system, breaking availability or causing data loss. 
Furthermore, attackers 
exploit a concurrency bugs to mount a privilege escalation attack.
A recent study~\cite{exprace} demonstrates that an user-level attacker 
reliably exploits non-deterministic concurrency bugs without performing
brute-force attacks.

Identifying kernel concurrency bugs is much more difficult than 
finding non-concurrency bugs. 
In contrast to non-concurrency bugs which can be identified by 
sequential testing of a single thread execution,
kernel concurrency bugs are typically caused by the concurrent execution 
of two or more threads.
Kernel concurrency bugs manifest only by a specific sequence of
instruction interleavings between threads. The interleavings happens 
rarely because it happens only when a specific timing condition is met.
To discover concurrency bugs, it is not practical to explore all
the possible interleavings because the number of instruction
executed by a system call in Linux is huge.
%Due to such difficulty, traditional fuzzers..

To increase efficiency of concurrency bug fuzzing, several approaches
have been proposed. SKI, Razzer, Snowboard, Krace.\yj{what else?}
\dr{as far as I know, there are conzzer and muzz}
% Snowboard uses edge-coverage...

\dr{I am thinking about not mentioning Snowboard as a fuzzer. In fact,
  it is *NOT* a concurrency fuzzer. The paper says Snowboard is a
  framework to generate concurrenct test cases using a fuzzer.}

\dr{Anyway, if we consider Snowboard as a fuzzer, Snowboard does not
  adopt an interleaving coverage metric, so it cannot distinguish two
  interleavings, and it relies on *heuristics* (= clustering
  strategies) to determine which interleavings should be explored}

To overcome the limitation of previous approaches, this paper proposes
\sys, a fuzzing framework for efficiently discovering kernel concurrency bugs.\yj{Do we focus only concurrency bugs?} \sys discovers not only data races but all interleaving-related bugs. 
At its core, \sys aims to systematically explore the vast thread
interleaving search space to quickly locate the multi-thread input and 
interleavings leading to a concurrency bug. The key design idea of \sys 
is i) defining a new, effective coverage metric reflecting the 
common nature of concurrency bugs, and ii) performing an efficient search
strategy to explore untested interleavings guided by the coverage metric.
Hence, we show that \sys discovers concurrency bugs more quickly than 
other approaches without compromising bug detecting capability 
(sometimes, having better capability than previous work), saving a huge 
amount of CPU costs in a large scale fuzzing. \sys achieves the goal 
with the following two key ideas: segmentizing thread interleaving and speculative exploration  of interleavings.

\PP{Segmentizing thread interleaving} From the execution of two threads,  
\sys decomposes the large thread interleaving space into tractable 
small sub-spaces, called \textit{interleaving segment} in which
instructions access shared memory objects. The number of instructions 
in a segment is small (at most four by default), and each segment may 
contain multiple interleavings. Using interleaving segment, we propose 
our new coverage metric, \textit{\intcov}, defined as a set of detected segments. \Intcov generalizes coverage 
metrics proposed by previous approaches where they only tracks 
a single interleaving (the size of segment is 2)\yj{OK?}. 
Using \intcov provides two benefits to fuzzers. First, a fuzzer can 
consider interactions of multiple interleavings, which increase 
accuracy of discovering concurrency bugs than considering a single 
interleavings. A previous study\cite{learningfrommistakes} observes that
most concurrency bugs occurs by interactions of at most four memory accesses of shared memory objects, implying multiple interleavings.
Second, a fuzzer can generate unexplored interleavings for the next 
search by referring to \intcov.

\PP{Speculative exploration of interleavings} To explore new interleavings,
\sys mutates observed interleavings recorded in \intcov. For mutating a segment, \sys changes interleaving orders of observed interleavings 
in a 


\yj{DR write some implementation summary and evaluation digests.}


We describe our contributions in three folds:

\begin{itemize}
\item interleaving segment coverage
\item speculative interleaving exploration based on explored interleaving
\item We have found \totalbugs race conditions.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
