\section{Introduction}
\label{s:intro}

%\dr{I make a decision to denote ``(thread) interleaving'' as a whole
%  interleaving. MUZZ and Krace use the term like this.}

Concurrency bugs are common in modern kernels due to 
the pervasive adoption of efficient but difficult-to-reason
parallelization techniques.
The consequence of kernel concurrency bugs is disastrous. They crash
the entire system, breaking availability\yj{cites} or causing data loss\yj{cites: check snowboard}.
Furthermore, attackers 
exploit concurrency bugs to mount a privilege escalation attack.
A recent study~\cite{exprace} demonstrates that a user-level attacker 
reliably exploits non-deterministic concurrency bugs without performing
brute-force attacks.

Identifying kernel concurrency bugs is much more difficult than 
finding non-concurrency bugs. 
In contrast to non-concurrency bugs which are identified by 
sequential testing of a single thread execution,
kernel concurrency bugs are typically caused by the concurrent execution 
of two or more threads.
Kernel concurrency bugs only emerge in a particular pattern of 
interleavings between threads. The thread interleaving happens 
rarely because it takes place only when a certain timing condition is met.
However, to discover concurrency bugs, exploring all the possible interleavings is not practical because 
the number of instructions executed by a system call in Linux is huge.
%Due to such difficulty, traditional fuzzers..

To increase efficiency of concurrency bug fuzzing, several approaches
have been proposed. SKI, Razzer, Snowboard, Krace.\yj{what else?}
\dr{as far as I know, there are conzzer and muzz}
% Snowboard uses edge-coverage...


\dr{If we consider Snowboard as a fuzzer, Snowboard does not
  adopt an interleaving coverage metric, so it cannot distinguish two
  interleavings, and it relies on *heuristics* (= clustering
  strategies) to determine which interleavings should be explored}


To overcome the shortcoming of existing methods, this paper proposes
\sys, a fuzzing framework for kernel concurrency bugs. 
\sys discovers not only data races but 
all interleaving-related bugs. 
At its core, \sys aims to systematically explore the vast thread
interleaving search space to quickly identify the multi-thread input and 
interleavings leading to a concurrency bug. The central idea behind \sys's design
is i) defining a new, effective coverage metric that reflects the 
common nature of concurrency bugs and ii) use that metric to drive 
an efficient search strategy for discovering previously untested interleavings.
Hence, we demonstrate that \sys saves a significant amount of CPU expenses 
in large-scale fuzzing by fast finding concurrent bugs, 
without sacrificing bug-detecting capability (sometimes having better 
capability than earlier work).
\sys achieves the goal with the following two key ideas: segmentizing thread interleaving and speculative exploration  of interleavings.

\PP{Segmentizing thread interleaving} From the execution of two threads,  
\sys decomposes the large thread interleaving space into tractable 
small sub-spaces, called \textit{interleaving segment} in which
instructions access shared memory objects. The number of instructions 
in a segment is small (at most four by default), and each segment may 
contain multiple interleavings. Using interleaving segments, we propose 
our new coverage metric, \textit{\intcov}, defined as a set of detected segments. \Intcov generalizes coverage 
metrics proposed by previous approaches where they only tracks 
a single interleaving (the size of a segment is 2)\yj{OK?}. 
Using \intcov provides two benefits to fuzzers. First, a fuzzer can 
take into account the interactions of multiple interleavings, which increases
accuracy of discovering concurrency bugs in comparison to considering a single 
interleavings. A previous study~\cite{learningfrommistakes} identifies that
most concurrency bugs occurs by multiple interleavings involving 
at most four memory accesses of shared memory objects.
Second, using \intcov, a fuzzer can produce a thread interleaving
that have not yet been found for the subsequent search.

\PP{Speculative exploration of interleavings} \yj{Speculative exploration
might be a misleading term} To explore new interleavings,
\sys mutates observed interleavings recorded in \intcov. For mutating a segment, \sys changes interleaving orders of observed interleavings 
in a segment, which generates new interleavings for testing. \sys 
mutates as many segments as possible in the expectation that the 
new interleavings include a large number of untested interleavings. 
This search strategy quickly navigates the search space than previous 
approaches in which only one interleaving is mutated at each search step

We implement \sys across various software layers.
We extend Syzkaller~\cite{syzkaller} to generate concurrency fuzzing inputs 
and segment mutations. 
%
In addition, \sys incorporates a LLVM pass to transform a kernel
binary for tracking \intcov, and the QEMU/KVM-based execution engine
to enforce thread scheduling obtained by segment mutations. 
%
We run \sys against the latest version of the Linux kernel (ranging
from 5.19-rc2 to 6.0-rc7), and find new \totalbugs concurrency bugs all of
which exhibits harmful behaviors such as memory corruption,
task hangs, or assertion violations. We emphasize that all
concurrency bugs found by \sys were lurking in subsystems where
Syzkaller~\cite{syzkaller} has been testing for several years, which
demonstrates the usefulness of \sys in bug-finding capability.
%
To quantify the efficiency of \sys, we experimentally compare \sys 
against the state-of-the-art techniques, Snowboard and KRACE and 
demonstrate that \sys discover concurrency bugs more quickly 
(up to \yj{xx}$\times$) than previous work using the segment mutation 
technique.

We describe our contributions in three folds:

\begin{itemize}
\item interleaving segment coverage
\item speculative interleaving exploration based on explored interleaving
\item We have found \totalbugs race conditions.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
