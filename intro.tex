\section{Introduction}
\label{s:intro}


Multi-core era, many techniques are integrated in kernel to improve performance. 

The consequence of kernel concurrency bugs is disastrous. They crash
the entire system, breaking availability or causing data loss. 
Furthermore, attackers 
exploit a concurrency bugs to mount a privilege escalation attack.
A recent study~\cite{exprace} demonstrates that an user-level attacker 
reliably exploits non-deterministic concurrency bugs without performing
brute-force attacks.

Identifying kernel concurrency bugs is much more difficult than 
finding non-concurrency bugs. 
In contrast to non-concurrency bugs which can be identified by 
sequential testing of a single thread execution,
kernel concurrency bugs are typically caused by the concurrent execution 
of two or more threads.
Kernel concurrency bugs manifest only by a specific sequence of
instruction interleavings between threads. The interleavings happens 
rarely because it happens only when a specific timing condition is met.
To discover concurrency bugs, it is not practical to explore all
the possible interleavings because the number of instruction
executed by a system call in Linux is huge.
%Due to such difficulty, traditional fuzzers..

To increase efficiency of concurrency bug fuzzing, several approaches
have been proposed. SKI, Razzer, Snowboard, Krace.\yj{what else?}
\dr{as far as I know, there are conzzer and muzz}
% Snowboard uses edge-coverage...


\dr{If we consider Snowboard as a fuzzer, Snowboard does not
  adopt an interleaving coverage metric, so it cannot distinguish two
  interleavings, and it relies on *heuristics* (= clustering
  strategies) to determine which interleavings should be explored}


To overcome the limitation of previous approaches, this paper proposes
\sys, a fuzzing framework for efficiently discovering kernel concurrency bugs.\yj{Do we focus only concurrency bugs?} \sys discovers not only data races but all interleaving-related bugs. 
At its core, \sys aims to systematically explore the vast thread
interleaving search space to quickly locate the multi-thread input and 
interleavings leading to a concurrency bug. The key design idea of \sys 
is i) defining a new, effective coverage metric reflecting the 
common nature of concurrency bugs, and ii) performing an efficient search
strategy to explore untested interleavings guided by the coverage metric.
Hence, we show that \sys discovers concurrency bugs more quickly than 
other approaches without compromising bug detecting capability 
(sometimes, having better capability than previous work), saving a huge 
amount of CPU costs in a large scale fuzzing. \sys achieves the goal 
with the following two key ideas: segmentizing thread interleaving and speculative exploration  of interleavings.

\PP{Segmentizing thread interleaving} From the execution of two threads,  
\sys decomposes the large thread interleaving space into tractable 
small sub-spaces, called \textit{interleaving segment} in which
instructions access shared memory objects. The number of instructions 
in a segment is small (at most four by default), and each segment may 
contain multiple interleavings. Using interleaving segment, we propose 
our new coverage metric, \textit{\intcov}, defined as a set of detected segments. \Intcov generalizes coverage 
metrics proposed by previous approaches where they only tracks 
a single interleaving (the size of segment is 2)\yj{OK?}. 
Using \intcov provides two benefits to fuzzers. First, a fuzzer can 
consider interactions of multiple interleavings, which increase 
accuracy of discovering concurrency bugs than considering a single 
interleavings. A previous study\cite{learningfrommistakes} observes that
most concurrency bugs occurs by interactions of at most four memory accesses of shared memory objects, implying multiple interleavings.
Second, a fuzzer can generate unexplored interleavings for the next 
search by referring to \intcov.

\PP{Speculative exploration of interleavings} To explore new interleavings,
\sys mutates observed interleavings recorded in \intcov. For mutating a segment, \sys changes interleaving orders of observed interleavings 
in a segment, which generates new interleavings for testing. \sys 
mutates as many segments as possible in the expectation that the 
new interleavings include a large number of untested interleavings. 
This search strategy quickly navigates the search space than previous 
approaches where it only mutates a single interleaving in each search step.



\yj{DR write some implementation summary and evaluation digests.}
We implmenet \sys across various software layers.
%
The \sys's core fuzzing framework embracing the aforementioned key
ideas is implemented based on Syzkaller~\cite{syzkaller}. In addition,
\sys incorporates a LLVM pass to trace memory accesses and basic
blocks during runtime, and the execution engine based on QEMU/KVM to
enforce thread scheduling as desired.
%
We run \sys against the latest version of the Linux kernel (ranging
from 5.19-rc2 to 6.0-rc7), and find \totalbugs concurrency bugs of
which all of them show harmful behaviors such as memory corruptions,
task hangs, or assertion violations. We also emphasize that all
concurrency bugs are found in subsystems where
Syzkaller~\cite{syzkaller} has been testing for several years, which
demonstrates the effectiveness of \sys.
%
Moreover, we experimentally compare \sys against the state-of-the-art
related work, Snowboard~\cite{snowboard} and Krace~\cite{krace},
showing that \sys can explore thread interleavings more quickly than
these works.





We describe our contributions in three folds:

\begin{itemize}
\item interleaving segment coverage
\item speculative interleaving exploration based on explored interleaving
\item We have found \totalbugs race conditions.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
