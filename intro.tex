\section{Introduction}
\label{s:intro}

%\dr{I make a decision to denote ``(thread) interleaving'' as a whole
% interleaving. MUZZ and Krace use the term like this.}

\dr{remind me: Krace --> KRACE, speculative --> mutation-based}

Concurrency bugs are common in modern kernels due to 
the pervasive adoption of efficient but difficult-to-reason
parallelization techniques.
The consequence of kernel concurrency bugs is disastrous. They crash
the entire system, breaking availability~\cite{cve201812232, snowboardbug} or causing data loss~\cite{dataloss}.
Furthermore, attackers 
exploit concurrency bugs to mount a privilege escalation attack.
A recent study~\cite{exprace} demonstrates that a user-level attacker 
reliably exploits non-deterministic concurrency bugs without performing
brute-force attacks.

Identifying kernel concurrency bugs is much more difficult than 
finding non-concurrency bugs. 
In contrast to non-concurrency bugs which are identified by 
sequential testing of single-thread execution,
kernel concurrency bugs are typically caused by the concurrent execution 
of two or more threads. 
Kernel concurrency bugs only emerge in a particular pattern of 
interleavings between threads. The thread interleaving happens 
rarely because it takes place only when a certain timing condition is met.
Therefore, the kernel concurrency fuzzer must consider two dimensions: 
how to navigate thread interleaving and generate multi-thread input seeds (e.g., system call pairs and their parameter values).
Unfortunately, exploring all the possible interleavings is not practical because 
The number of instructions executed by a system call in Linux is huge.
Due to such difficulty, traditional fuzzers

%\dr{as far as I know, there are conzzer and muzz}
%\dr{If we consider Snowboard as a fuzzer, Snowboard does not
%  adopt an interleaving coverage metric, so it cannot distinguish two
%  interleavings, and it relies on *heuristics* (= clustering
%  strategies) to determine which interleavings should be explored}
To increase the efficiency of concurrency bug fuzzing, several approaches
have been proposed for exploring thread interleaving. 
Razzer~\cite{razzer} uses static analysis whereas
Snowboard~\cite{snowboard} uses dynamic analysis
to identify instruction pairs that access the same objects.
From detected instruction pairs, they use heuristics 
to produce new thread interleaving. Alas, they are coverage-oblivious, 
so they cannot prune redundant executions of thread interleaving
that produce identical results. We underline that 
coverage-guided searching is the preferred strategy 
for concurrency fuzzing. However, what form of coverage would be 
effective in concurrency fuzzing has not been researched extensively.
KRACE~\cite{krace} proposes alias coverage, which simply tracks 
a single alias-pair instruction. We observe that tracking single 
Instruction pairs are not sufficient. Furthermore, KRACE uses 
the alias coverage to decide whether to continue to explore or not 
in the current multi-threaded input. When exploring a thread 
interleaving space, it takes a randomized approach, 
sharing the similar inefficiencies of previous techniques.

To overcome the shortcoming of existing methods, this paper proposes
sys, a fuzzing framework for kernel concurrency bugs. 
\sys discovers not only data races but 
all interleaving-related bugs. 
At its core, \sys aims to systematically explore the vast thread
interleaving search space to quickly identify the multi-thread input and 
interleavings leading to a concurrency bug The central idea behind \sys's design
is i) defining a new, effective coverage metric that reflects the 
common nature of concurrency bugs and ii) use that metric to drive 
an efficient search strategy for discovering previously untested interleavings.
Hence, we demonstrate that \sys saves a significant amount of CPU expenses 
in large-scale fuzzing by fast finding concurrent bugs, 
without sacrificing bug-detecting capability (sometimes having better 
capability than earlier work).
\sys achieves the goal with the following two key ideas: segmenting thread interleaving and speculative exploration of interleavings.

\PP{Segmentizing thread interleaving} From the execution of two threads,  
\sys decomposes the large thread interleaving space into tractable 
small sub-spaces, called \textit{interleaving segment} in which
instructions access shared memory objects. The number of instructions 
in a segment is small (at most four by default), and each segment may 
contain multiple interleavings. Using interleaving segments, we propose 
our new coverage metric, \textit{\intcov}, which is defined as a set of detected segments. \Intcov generalizes coverage 
metrics proposed by previous approaches where they only track 
a single interleaving (the size of a segment is 2). 
Using \intcov provides two benefits to fuzzers. First, a fuzzer can 
take into account the interactions of multiple interleavings, which increases
accuracy of discovering concurrency bugs in comparison to considering a single 
interleavings. A previous study~\cite{learningfrommistakes} identifies that
most concurrency bugs occur by multiple interleavings involving 
at most four memory accesses of shared memory objects.
Second, using \intcov, a fuzzer can produce a thread interleaving
that have not yet been found for the subsequent search.

\PP{Mutating interleaving segments} 
%
To explore new interleavings,
\sys mutates the mutates observed interleavings recorded in \intcov. For mutating a segment, \sys changes interleaving orders of observed interleavings 
in a segment, which generates new interleavings for testing. \sys 
mutates as many segments as possible in the expectation that the 
new interleavings include a large number of untested interleavings. 
This search strategy quickly navigates the search space than previous 
approaches in which only one interleaving is mutated at each search step

We implement \sys across various software layers.
We extend Syzkaller~\cite{syzkaller} to generate concurrency fuzzing inputs 
and segment mutations. 
%
In addition, \sys incorporates an LLVM pass to transform a kernel
binary for tracking \intcov, and the QEMU/KVM-based execution engine
to enforce thread scheduling obtained by segment mutations. 
%
We run \sys against the latest version of the Linux kernel (ranging
from 5.19-rc2 to 6.0-rc7), and find new \totalbugs concurrency bugs all of
which exhibits harmful behaviors such as memory corruption,
task hangs, or assertion violations. We emphasize that all
concurrency bugs found by \sys were lurking in subsystems where
Syzkaller~\cite{syzkaller} has been testing for several years, which
demonstrates the usefulness of \sys in bug-finding capability.
%
To quantify the efficiency of \sys, we experimentally compare \sys 
against the state-of-the-art techniques, Snowboard and KRACE and 
demonstrate that \sys discover concurrency bugs more quickly 
(up to \yj{xx}$\times$) than previous work using the segment mutation 
technique.

We describe our contributions in three folds:

\begin{itemize}
\item interleaving segment coverage
\item speculative interleaving exploration based on explored interleaving
\item We have found \totalbugs race conditions.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
