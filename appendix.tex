\section{Appendix}

%\subsection{}
%label{s:appendix:preemption}

%A few prior approaches~\cite{ski, snowboard, razzer} suspend a vCPU
%instead of a guest thread. While suspending a vCPU grants the ability
%to control an interleaving, it is not suitable for our purpose because
%suspending a vCPU may unexpectedly suspend another vCPU. An example we
%observed is TLB shootdown~\cite{tlbshootdown}. When a vCPU wants TLB
%shootdown, it sends inter-process interrupts (IPIs) to all cores and
%wait until all cores to execute the TLB shootdown handler.  In this
%case, if one vCPU is entirely suspended, the TLB shootdown cannot be
%successfully conducted causing the vCPU invoking TLB shootdown
%blocked.
%
%Therefore, instead of adopting the prior approach, our hypervisor is
%designed to suspends and resumes a guest thread.


\subsection{Hashing segment graph}
\label{s:appendix:hash}
% \dr{I want to discuss about this part. I'm thinking taking this part
%   out to the appendix section:}
% %
In particular, for all vertices $v$ in $V_i$, we first calculate a
hash value of $v$, $hash(v)$, which reflects its out-going edges. With
$o_1, ..., o_m$ that $v \rightarrow o_x \in E_i$,
%
%
\\[1pt]
\[
  hash(v) = \mathcal{H}(v.label {++} o_1.label {++} ... {++}
  o_m.label)
\]
\\[1pt]
%
where $\mathcal{H}$ denotes the
non-cryptographic FNV hash function~\cite{fnv, fnv-go}, and ${++}$
denotes the label-concatenation operation.
%
Then,
%
\\[1pt]
\[
  hash(g_i) = \underset{v \in V_i}{\oplus} hash(v)
\]
\\[1pt]
%
where $\oplus$ denotes the XOR operation.




\subsection{Virtual Machine Introspection}
\label{s:appendix:vmi}


As a hardware breakpoint does not distinguish the running context of a
kernel, if the context switch happens, a breakpoint may be hit by
another thread or an interrupt handler, making the execution out of
expectation.
%
The hypervisor recognizes a running context using \texttt{task_struct}
which holds the thread description, and the per-cpu
\texttt{preempt_count} variable indicating what context the thread is
in (\eg, a task context for running a syscall, or a hardIRQ context to
handle hardware interrupts).
%
If a breakpoint is hit by a context other than the fuzzer-controlled
thread, our hypervisor ignores it and keeps the breakpoint.



When the suspended thread already acquires a lock while the running
thread wants to hold the same lock, the whole execution cannot make a
progress, because our hypervisor forces the lock-holding thread to
suspend.
%
Therefore, our hypervisor inspects whether the running thread is going
to be blocked due to the lock contention, and if it is, our hypervisor
takes control from the running thread to the suspended thread.
%
Inspecting the lock contention is conducted by hooking lockdep
functions~\cite{lockdep} that are commonly called from synchronization
prmitives.
%
When the lockdep functions are called, our hypervisor determins
whether the running thread can make a progress through various
information such as the address of the synchronization primitive, and
operation type (\ie, lock, unlock, and trylock).


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
