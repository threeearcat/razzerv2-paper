\section{Exploring Thread Interleaving Space}
\label{s:design}

In this section, we describe our approach to effectively achieve the
two design goals, \textbf{R1} and \textbf{R2}.
%
We first explain the key idea of our
approach~(\autoref{ss:overview}). Then, we illustrate our concurrency
coverage metric to achieve \textbf{R1}~(\autoref{ss:coverage}) and the
instruction scheduling mechanism to quickly saturate the
coverage (\eg, satisfying \textbf{R2})~(\autoref{ss:scheduler}).


While this section focuses only on exploring the search space of
thread interleaivng of a given multi-thread seed, the whole design of
\sys will be explained later in \autoref{s:impl}.


\subsection{Key Idea: Segmentizing thread interleaving}
\label{ss:overview}

% Overall 1 2 3 4 5
% 74 0 22 33 12 7

\begin{table}[t]
  \centering
  \input{table/learningfrommistakes.tex}
  \caption{Statistics provided by Shan Lu
    \etal~\cite{learningfrommistakes}, stating the number of
    concurrency bugs according to the number of memory accesses
    involved in the manifestation of a concurrency bug.}
  \label{table:learningfrommistakes}
\end{table}

Our key idea starts from an extensive survey conducted by Shan Lu
\etal~\cite{learningfrommistakes}.
%
As stated in \autoref{table:learningfrommistakes}, 92.4\% (97 out of
105) of concurrency bugs they study manifest depending only on the
execution order of at most four memory accesses; all other memory
accesses and their execution orders do not affect the manifestation of
a concurrency bug.
%
The example of \autoref{fig:cve-2019-6974} also follows this survey
since the uninitialized access is triggered depending only on the
execution order of three memory accesses (\eg, \texttt{A2},
\texttt{A4} and \texttt{B1}), while others (\eg, \texttt{A6} and
\texttt{B2}) are irrelevant to the concurrency bug.


This survey suggests a balance point of a trade-off between the
completeness of the bug-finding capability and the complexity of
exploring the search space of thread interleaving;
%
If one searches for all interleaving instances, he or she is able to
discover all concurrency bugs with a cost of astronomical time, and
if one focuses on the execution order of at most two instructions, he
or she quickly gets his job done with a risk of a high chance of
missing many (\eg, about 70\%) concurrency bugs.
%
Whereas, this paper sits between these two extremes. We track and
search for interleaving orders of at most four memory accesses to make
the problem tractable while maintaining a strong bug-finding
capability.



\PP{Segmentizing thread interleaving}
%
Based on the survey, the key idea of our approach is to consider an
instance of thread interleaving as \textit{a composition of
  interleaving segments}, where each interleaving segment represents
interleaving orders between a small number of memory accesses.
%
In particular, after executing threads concurrently, we firstly model
an execution of these threads as a totally-ordered instruction
sequence.
%
And then, we group a small number of instructions (\eg, four
instructions), as a segment to track which segments are contained in
the execution and to search for unobserved segments in future
iterations.

\begin{figure}[t]
  \subfloat[Interleaving instance\label{fig:keyidea-a}]{
    \includegraphics[width=0.35\linewidth]{fig/intuition-a.pdf}
  }
  \hfill
  \subfloat[Interleaving segments\label{fig:keyidea-b}]{
    \includegraphics[width=0.55\linewidth]{fig/intuition-b.pdf}
  }
  \caption{(a) An interleaving instance example of
    \autoref{fig:cve-2019-6974} that does not cause the concurrency
    bug, and (b) interleaving segments contained in the interleaving
    instance. Note that we intentionally omit instructions that do not
    access globally-visible memory objects.}
  \label{fig:keyidea}
\end{figure}
%
\autoref{fig:keyidea} visualizes our key idea.
%
Let us assume we execute the two system calls in
\autoref{fig:cve-2019-6974} concurrently, and \autoref{fig:keyidea-a}
represents the interleaving instance of the execution. Note that this
execution does not cause the uninitialized access bug because
\texttt{B1} is executed after \texttt{A4}.
%
As we want to focus on a small number (\eg, four) of instructions, we
then decompose the interleaving instance into several interleaving
segments where each interleaving segment describes interleaving orders
of memory accesses.
%
\autoref{fig:keyidea}-(b) describes three interleaving segments
contained in the interleaving instance of \autoref{fig:keyidea-a}.
%

%
It is worth noting that interleaving segments can be overlapped; in
this example, \texttt{Segment \#1} and \texttt{Segment \#3} are
overlapped over an interleaving order
$\texttt{A4} \Rightarrow \texttt{B1}$.




\PP{Benefits of thread interleaving segmentization}
%
This approach provides two remarkable benefits:
%
First, tracking interleaving segments is a befitting choice to
determine if any interesting thread interleaving remains untested.
%
As mentioned above, most concurrency bugs manifest depending only on
the execution order of a few memory accesses.
%
In this perspective, whether or not an interleaving instance causes a
concurrency bug depends on whether or not an erroneous interleaving
segment (\ie, one describing errorneous thread interleaving) is
contained in the instance of thread interleaving.
%
Therefore, from a multi-thread seed, if a fuzzer observed all possible
interleaving segments with size of four, it can confidently conclude
that the multi-thread seed will not expose a concurrency bug.
%



Second, observed interleaving segments can be used to teach a fuzzer
which interleaving instances should be tested in future iterations.
%
\autoref{fig:hint} demonstrates how an observed interleaving segment
can be helpful for future iterations.
%
\texttt{Segment \#1} is an interleaving segment described in
\autoref{fig:keyidea-b}.
%
With this interleaving segment, we can derive \textit{unobserved
  interleaving segments} by rearranging instructions in the
interleaving segment.
%
As illustrated in \autoref{fig:hint}, by changing the execution order
of three instructions, \texttt{A2}, \texttt{A4} and \texttt{B1} in
\texttt{Segment \#1}, we can derive two unobserved interleaving
segments \texttt{Segment \#1-a} and \texttt{Segment \#1-b}.
%
These two derived interleaving segments can be indicators to teach a
fuzzer what to search for in future iterations, and if a fuzzer
executes \texttt{Segment \#1-b}, it will discover the uninitialized
bug.
%
\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{fig/hint.pdf}
  \caption{\texttt{Segment \#1} is observed in \autoref{fig:keyidea},
    and \texttt{Segment \#1--a} and \texttt{Segment \#1}--b are
    \textit{unobserved} interleaving segments derived from
    \texttt{Segment \#1}.}
  \label{fig:hint}
\end{figure}
%



\subsection{Interleaving Segment Coverage}
\label{ss:coverage}

\newcommand{\mutable}{mutable edge\xspace}
\newcommand{\mutables}{mutable edges\xspace}
\newcommand{\immutable}{immutable edge\xspace}
\newcommand{\immutables}{immutable edges\xspace}


Based on the key idea, we propose a novel concurrency coverage metric
called interleaving segment coverage.
%
Interleaving segment coverage is designed to track the interleaving
order of a small number of memory accesses, and if per-input
interleaving segment coverage is saturated, we confidently conclude
that the multi-thread input unlikely causes a concurrency bug.


We compute interleaving segment coverage \textit{offline}; While
executing a multi-thread input, the fuzzer only collects memory access
operations conducted by the multi-thread input, and after the
execution is finished, the fuzzer computes interleaving segment
coverage of the multi-thread input.


\PP{Graph representation of interleaving segment}
%
We represent each interleaving segment as a small graph.
%
In this graph, vertices represent memory access operations, and edges
represent XXX.
%
In particular, there are two types of edges, intra-thread edges and
inter-thread edges.


%
% Let us represent a memory access operation $M$ as four tuples,
% $(tid, addr, op, timestamp)$ where $tid$ is the identity of a thread,
% $addr$ is the address of a memory location, $op$ is the type of the
% memory access operation (\ie, $store$ or $load$), and $timestamp$
% indicates the point of time when the memory access operation is taken.
% %
% $M(x)$ detnoes a field $x$ of $M$. For example, $M(tid)$ is a $tid$
% field of a memory access operation $M$.
% %
% Also let us suppose all memory access operations are totally
% ordered. \ie, there are no two memory access operations that have the
% same $timestamp$.

% For all pair of memory access operations $M_i$ and $M_j$, we define a
% scheduling constraint $SC$ as a tuple $(M_i, M_j)$ if
% $M_i(tid) \neq M_j(tid)$, $M_i(addr) = M_j(addr)$,
% $M_i(op) = store \vee M_j(op) = store$, and
% $M_i(timestamp) < M_j(timestamp)$.
% %
% Informally, $M_i$ and $M_j$ are conflicting memory acceess operations
% that are executed in other threads, and $M_i$ was taken place before
% $M_j$.
% %
% For two scheduling constraint $SC_1(M_{1i}, M_{1j})$ and
% $SC_2(M_{2i}, M_{2j})$, $SC_1 = SC_2$ if
% $(M_{1i} = M_{2i}) \wedge (M_{1j} = M_{2j})$.
% %
% Then, we define a scheduling constraint pair $SCPair = (SC_i, SC_j)$
% for two scheduling constraints if $i < j$, $SC_i \neq SC_j$.
% %
% Lastly, biconflict coverage of the concurrent job $BC\mbox{-}Cov$ is
% defined as a set of all scheduling constraint pairs,
% $\{SCPair_1, SCPair_2, ..., SCPair_n\}$, constructed from its memory
% access operation sequence.


\PP{Interleaving segment coverage}


\PP{Deriving unobserved interleaving segement}
%
As described in \autoref{ss:overview}, observed interleaving segments
are used to infer

\dr{}

% An interleaving finding new biconflict coverage likely exposes a
% behavior that was unrevealed before.
% %
% To discover more interesting behaviors, if new biconflict coverage is
% found, the fuzzer mutates the interleaving. \ie, the fuzzer
% reschedules instructions to conform with other interleavings.

% Before mutating an interleaving, the fuzzer predicts \textit{potential
%   biconflict coverage}, $BC\mbox{-}Cov^*$, a set of scheduling
% constraint pairs that \textit{has not been observed but is expected to
%   occur with other interleavings}.
% %
% Potential binconflict coverage will be used to direct the interleaving
% mutation. \ie, the fuzzer will try to generate interleavings to expose
% undisclosed scheduling constraint pairs contained in
% $BC\mbox{-}Cov^*$, instead of blindly mutating an interleaving.


% $BC\mbox{-}Cov^*$ is derived from biconflict coverage $BC\mbox{-}cov$,
% $\{SCPair_1, SCPair_2, ..., SCPair_n\}$.
% %
% For each $SCPair_i$ composed of $(SC_x, SC_y)$ in $BC\mbox{-}cov$, the
% fuzzer derives \dr{TODO}...



\subsection{Coverage-directed Interleaving Mutation}
\label{ss:scheduler}

\newcommand{\segment}{segment graph\xspace}
\newcommand{\segments}{segment graphs\xspace}
\newcommand{\Segments}{Segment graphs\xspace}


After tracking biconflict coverage of an interleaving, our
interleaving mutation takes potential biconflict coverage
$BC\mbox{-}Cov^*$ as a hint for further mutation.
%
The goal of the interleaving mutation is to generate other
interleavings that may cover scheduling constraint pairs in
$BC\mbox{-}Cov^*$.
%
Until $BC\mbox{-}Cov^*$ is not empty, the fuzzer repeats two steps of
the interleaving mutation:
%
1) selecting scheduling constraint pairs to test, and
2) generating scheduling points to test the selected scheduling
constraint pairs.

\dr{wip.}

\PP{Selecting scheduling constraints to ...}
%
Among scheduling constraint pairs in $BC\mbox{-}Cov^*$, some of them
cannot be obeyed simultaneously.
%
For example, an interleaivng obviously cannot obey the two scheduling
constraints $(X \rightarrow Y)\wedge (Z \rightarrow W)$ and
$(Y \rightarrow X)\wedge (Z \rightarrow W)$ because of the
contradiction on the execution order of $X$ and $Y$.
%
We thus 


It may require heavy computation to identify the largest subset of
$BC\mbox{-}Cov^*$ that are all harmonious to each other.
%
Instead of finding the optimal solution, we choose to use a greedy
algorithm.
%


Especially, given uncaptured \segments extracted from an interleaving
graph, our interleaving mutation starts by selecting a random
\segment.
%
And then it iteratively selects a \segment while confirming that the
selected \segment is harmonious.
%
Determining a given \segment is harmonious is conducted by checking a
loop in an accumulated interleaving graph.



\PP{Generating scheduling points}
%
After selecting harmonious \segments, generating scheduling points can
be easily done by conducting a topological
sort~\cite{topologicalsort}.
%
Since an imaginary interleaving graph is acyclic, a topological sort
always returns a sequence of vertices (\ie, instructions) that does
not violate a program order.
%
It is well known that the time complexity of a topological sort is
$O(V+E)$. Considering that the graph is sparse, $E$ is a small value
so the time complexity can be asymptotically considered as $O(V)$.
%
In this sequence, scheduling points are just instructions that the
preemption should happen; \ie, the next instruction is executed by a
different thread.
%



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
