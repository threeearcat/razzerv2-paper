\section{Exploring Thread Interleaving Space}
\label{s:design}

In this section, we describe our approach to effectively achieve the
two design goals, \textbf{R1} and \textbf{R2}.
%
We first explain the key idea of our
approach~(\autoref{ss:overview}). Then, we illustrate our concurrency
coverage metric to achieve \textbf{R1}~(\autoref{ss:coverage}) and the
instruction scheduling mechanism to quickly saturate the coverage
metric (\eg, satisfying \textbf{R2})~(\autoref{ss:scheduler}).


While this section focuses only on exploring the search space of
thread interleaivng of a given multi-thread input, the whole design of
\sys will be explained later in \autoref{s:impl}.


\subsection{Key Idea: Segmentizing thread interleaving}
\label{ss:overview}

% Overall 1 2 3 4 5
% 74 0 22 33 12 7

\begin{table}[t]
  \centering
  \input{table/learningfrommistakes.tex}
  \caption{Statistics provided by Shan Lu
    \etal~\cite{learningfrommistakes}, stating the number of
    concurrency bugs according to the number of memory accesses
    involved in the manifestation of a concurrency bug.}
  \label{table:learningfrommistakes}
\end{table}

Our key idea starts from an extensive survey conducted by Shan Lu
\etal~\cite{learningfrommistakes}.
%
As stated in \autoref{table:learningfrommistakes}, 92.4\% (97 out of
105) of concurrency bugs they study manifest depending only on the
execution order of at most four memory accesses; all other memory
accesses and their execution orders do not affect the manifestation of
a concurrency bug.
%
The example of \autoref{fig:cve-2019-6974} also follows this survey
since the uninitialized access is triggered depending only on the
execution order of three memory accesses (\eg, \texttt{A2},
\texttt{A4} and \texttt{B1}), while others (\eg, \texttt{A6} and
\texttt{B2}) are irrelevant to the concurrency bug.


This survey suggests a balance point of a trade-off between the
completeness of the bug-finding capability and the complexity of
exploring the search space of thread interleaving;
%
If one searches for all interleaving instances, he or she is able to
discover all concurrency bugs with a cost of astronomical time, and
if one focuses on the execution order of at most two instructions, he
or she quickly gets his job done with a risk of a high chance of
missing many (\eg, about 70\%) concurrency bugs.
%
Whereas, this paper sits between these two extremes. We track and
search for interleaving orders of at most four memory accesses to make
the problem tractable while maintaining a strong bug-finding
capability.



\PP{Segmentizing thread interleaving}
%
Based on the survey, the key idea of our approach is to consider an
instance of thread interleaving as \textit{a composition of
  interleaving segments}, where each interleaving segment represents
interleaving orders among a small number of memory accesses.
%
In particular, after executing threads concurrently, we firstly model
the execution as a totally-ordered instruction sequence.
%
And then, we group a small number of instructions (\eg, four
instructions), as an interleaving segment to track which segments are
contained in the execution and to search for unobserved segments in
future iterations.

\begin{figure}[t]
  \subfloat[Interleaving instance\label{fig:keyidea-a}]{
    \includegraphics[width=0.35\linewidth]{fig/intuition-a.pdf}
  }
  \hfill
  \subfloat[Interleaving segments\label{fig:keyidea-b}]{
    \includegraphics[width=0.55\linewidth]{fig/intuition-b.pdf}
  }
  \caption{(a) An interleaving instance example of
    \autoref{fig:cve-2019-6974} that does not cause the concurrency
    bug, and (b) interleaving segments with size of three and four
    contained in the interleaving instance. Note that we intentionally
    omit instructions that do not access globally-visible memory
    objects.}
  \label{fig:keyidea}
\end{figure}
%
\autoref{fig:keyidea} visualizes our key idea.
%
Let us assume we execute the two system calls in
\autoref{fig:cve-2019-6974} concurrently, and \autoref{fig:keyidea-a}
represents the interleaving instance of the execution. Note that this
execution does not cause the uninitialized access bug because
\texttt{B1} is executed after \texttt{A4}.
%
As we want to focus on a small number (\eg, four) of instructions, we
decompose the interleaving instance into several interleaving segments
as described in \autoref{fig:keyidea-b}.
%
In these interleaving segments, \texttt{Segment \#1} contains three
memory access operations (\ie, \texttt{A2}, \texttt{A4}, and
\texttt{B1}), and describes interleaving orders such that \texttt{B1}
is executed after \texttt{A2} and \texttt{A4}.
%
Similarly, \texttt{Segment \#2} and \texttt{Segment \#3} describes
interleaving orders of four memory access operations, (\texttt{A2},
\texttt{B1}, \texttt{B2}, \texttt{A6}) and (\texttt{A4}, \texttt{B1},
\texttt{B2}, \texttt{A6}) respectively.
%
It is worth noting that interleaving segments can be overlapped; in
this example, \texttt{Segment \#1} and \texttt{Segment \#3} are
overlapped over an interleaving order
$\texttt{A4} \Rightarrow \texttt{B1}$.




\PP{Benefits of thread interleaving segmentization}
%
Segmentizing thread interleaving provides two remarkable benefits to a
fuzzer:
%
First, tracking interleaving segments is a befitting choice to
determine if any interesting thread interleaving remains untested.
%
As mentioned above, most concurrency bugs manifest depending only on
the execution order of four memory access operations.
%
In this perspective, if a fuzzer observed all possible interleaving
segments with size of four from a multi-thread input, it can
confidently conclude that the multi-thread input will not expose a
concurrency bug.
%
Therefore, \textit{interleaving segments can be act as an interleaving
  coverage metric that allows a fuzzer to satisfy \textbf{R1}}.



Second, observed interleaving segments can be used to \textit{direct}
a fuzzer about what thread interlevaing needs to be tested in future
iterations.
%
\autoref{fig:hint} demonstrates how an observed interleaving segment
can be helpful for future iterations.
%
As illustrated in \autoref{fig:hint}, a fuzzer can derive
\textit{unobserved} \texttt{Segment \#1*} by changing the execution
order of \texttt{A4} and \texttt{B4} in \texttt{Segment \#1}.
%
Similarly, \texttt{Segment \#3*} can be derived from \texttt{Segment
  \#3} by changing the execution order of \texttt{A4} and \texttt{B1},
and \texttt{A6} and \texttt{B2}.
%
These two derived interleaving segments can be indicators to direct a
fuzzer which thread interleaving to search for in future
iterations.
%
Interestingly, these two derived interleaving segments can be tested
\textit{at the same time}. By executing an interleaving instance
including the two derived interleaving segments, a fuzzer is able to
quickly test a number of interleaving segments.
%
In this way, \textit{our proposed scheduler mechanism is designed to
  quickly explore unobserved interleaving segments, and to satisfy
  \textbf{R2}}.
%
\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{fig/hint.pdf}
  \caption{\texttt{Segment \#1} and \texttt{Segment \#3} are observed
    interleaving segments in \autoref{fig:keyidea}.
    %
    From these two interleaving segments, our approach derives other
    interleaving segments \texttt{Segment \#1*} and \texttt{\#3*}, and
    schedules instructions to test the derived interleaving segments
    at the same time.}
  \label{fig:hint}
\end{figure}
%



\subsection{Interleaving Segment Coverage}
\label{ss:coverage}

\newcommand{\mutable}{mutable edge\xspace}
\newcommand{\mutables}{mutable edges\xspace}
\newcommand{\immutable}{immutable edge\xspace}
\newcommand{\immutables}{immutable edges\xspace}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{fig/interleavingsegmentgraph.pdf}
  \caption{\texttt{Segment \#1} and its interleaving segment graph. A
    dotted arrow represents a program order, and solid arrows
    represent interleaving orders.}
  \label{fig:interleavingsegmentgraph}
\end{figure}

Based on the key idea, we propose a novel concurrency coverage metric
called interleaving segment coverage.
%
Interleaving segment coverage is designed to track the interleaving
order of a small number of memory accesses, and if per-input
interleaving segment coverage is saturated, a fuzzer can confidently
conclude that the multi-thread input unlikely causes a concurrency
bug.

\PP{Graph representation of interleaving segment}
%
We represent each interleaving segment as a small directed acyclic
graph called an interleaving segment graph.
%
In this graph, vertices represent memory access operations, and edges
represent orderings between two memory access operations.
%
Specifically, there are two types of orderings, program orders and
interleaving orders.
%
A program order indicates the execution order between two memory
access operations in a single thread.
%
On the other hand, an interleaving order represents the execution
order between two memory access operations that access the same shared
data and are executed by different threads.

Taking the example of \texttt{Segment \#1},
\autoref{fig:interleavingsegmentgraph} illustrates an interleaving
segment graph corresponding to \texttt{Segment \#1}.
%
This interleaving segment graph contains an edge from \texttt{A2} to
\texttt{A4} representing a program order between \texttt{A2} and
\texttt{A4}; \texttt{A2} is executed before \texttt{A4} in thread~A.
%
In addition, the interleaving segment graph contains two more edges
from \texttt{A2} to \texttt{B1}, and from \texttt{A4} to \texttt{B1},
representing interleaving orders between these two pairs of
instructions.


It is worth noting that an interleaving graph has two
properties. First, if a path exists from a vertex \texttt{X} to
another vertex \texttt{Y}, a memory access operation corresponding to
\texttt{X} is executed before a memory access operation corresponding
to \texttt{Y}.
%
\dr{}
This is because edges represent orderings that are a transitive
relation.
%
Second, \textit{all interleaving segment graph cannot contain a loop}.
%
If there is a loop exists, any vertex \texttt{Z} on the loop is
executed before itself, which is contradictory.


%
% Let us represent a memory access operation $M$ as four tuples,
% $(tid, addr, op, timestamp)$ where $tid$ is the identity of a thread,
% $addr$ is the address of a memory location, $op$ is the type of the
% memory access operation (\ie, $store$ or $load$), and $timestamp$
% indicates the point of time when the memory access operation is taken.
% %
% $M(x)$ detnoes a field $x$ of $M$. For example, $M(tid)$ is a $tid$
% field of a memory access operation $M$.
% %
% Also let us suppose all memory access operations are totally
% ordered. \ie, there are no two memory access operations that have the
% same $timestamp$.

% For all pair of memory access operations $M_i$ and $M_j$, we define a
% scheduling constraint $SC$ as a tuple $(M_i, M_j)$ if
% $M_i(tid) \neq M_j(tid)$, $M_i(addr) = M_j(addr)$,
% $M_i(op) = store \vee M_j(op) = store$, and
% $M_i(timestamp) < M_j(timestamp)$.
% %
% Informally, $M_i$ and $M_j$ are conflicting memory acceess operations
% that are executed in other threads, and $M_i$ was taken place before
% $M_j$.
% %
% For two scheduling constraint $SC_1(M_{1i}, M_{1j})$ and
% $SC_2(M_{2i}, M_{2j})$, $SC_1 = SC_2$ if
% $(M_{1i} = M_{2i}) \wedge (M_{1j} = M_{2j})$.
% %
% Then, we define a scheduling constraint pair $SCPair = (SC_i, SC_j)$
% for two scheduling constraints if $i < j$, $SC_i \neq SC_j$.
% %
% Lastly, biconflict coverage of the concurrent job $BC\mbox{-}Cov$ is
% defined as a set of all scheduling constraint pairs,
% $\{SCPair_1, SCPair_2, ..., SCPair_n\}$, constructed from its memory
% access operation sequence.


\PP{Interleaving segment coverage}
%

We compute interleaving segment coverage \textit{offline}; While
executing a multi-thread input, the fuzzer only collects memory access
operations conducted by the multi-thread input, and after the
execution is finished, the fuzzer computes interleaving segment
coverage of the multi-thread input.



Given an interleaving instance, all interleaving segment graphs with
at most four vertices could be 


size 3 and 4

no containing a vertex that is not connected with interleaving order

identity relation





\PP{Deriving unobserved interleaving segement}
%
As described in \autoref{ss:overview}, observed interleaving segments
(\eg, \texttt{Segment \#1} and \texttt{Segment \#3} in
\autoref{fig:hint}) are used to infer unobserved interleaving segments
(\eg, \texttt{Segment \#1*} and \texttt{Segment \#3*}) that a fuzzer
will search for in future iterations.
%
In our approach, this is done by generating other interleaving segment
graphs from a given interleaving segment graph.

After a fuzzer computes interleaving segment 

As a reminder, an interleaving segment graph contains two types of
edges, 


% An interleaving finding new biconflict coverage likely exposes a
% behavior that was unrevealed before.
% %
% To discover more interesting behaviors, if new biconflict coverage is
% found, the fuzzer mutates the interleaving. \ie, the fuzzer
% reschedules instructions to conform with other interleavings.

% Before mutating an interleaving, the fuzzer predicts \textit{potential
%   biconflict coverage}, $BC\mbox{-}Cov^*$, a set of scheduling
% constraint pairs that \textit{has not been observed but is expected to
%   occur with other interleavings}.
% %
% Potential binconflict coverage will be used to direct the interleaving
% mutation. \ie, the fuzzer will try to generate interleavings to expose
% undisclosed scheduling constraint pairs contained in
% $BC\mbox{-}Cov^*$, instead of blindly mutating an interleaving.


% $BC\mbox{-}Cov^*$ is derived from biconflict coverage $BC\mbox{-}cov$,
% $\{SCPair_1, SCPair_2, ..., SCPair_n\}$.
% %
% For each $SCPair_i$ composed of $(SC_x, SC_y)$ in $BC\mbox{-}cov$, the
% fuzzer derives \dr{TODO}...



\subsection{Coverage-directed Interleaving Mutation}
\label{ss:scheduler}



% After tracking biconflict coverage of an interleaving, our
% interleaving mutation takes potential biconflict coverage
% $BC\mbox{-}Cov^*$ as a hint for further mutation.
% %
% The goal of the interleaving mutation is to generate other
% interleavings that may cover scheduling constraint pairs in
% $BC\mbox{-}Cov^*$.
% %
% Until $BC\mbox{-}Cov^*$ is not empty, the fuzzer repeats two steps of
% the interleaving mutation:
% %
% 1) selecting scheduling constraint pairs to test, and
% 2) generating scheduling points to test the selected scheduling
% constraint pairs.

% \dr{wip.}

\PP{Selecting interleaving segments}
%
% Among scheduling constraint pairs in $BC\mbox{-}Cov^*$, some of them
% cannot be obeyed simultaneously.
% %
% For example, an interleaivng obviously cannot obey the two scheduling
% constraints $(X \rightarrow Y)\wedge (Z \rightarrow W)$ and
% $(Y \rightarrow X)\wedge (Z \rightarrow W)$ because of the
% contradiction on the execution order of $X$ and $Y$.
% %
% We thus


As described in \autoref{fig:hint}, 


% It may require heavy computation to identify the largest subset of
% $BC\mbox{-}Cov^*$ that are all harmonious to each other.
% %
% Instead of finding the optimal solution, we choose to use a greedy
% algorithm.
% %


% Especially, given uncaptured \segments extracted from an interleaving
% graph, our interleaving mutation starts by selecting a random
% \segment.
% %
% And then it iteratively selects a \segment while confirming that the
% selected \segment is harmonious.
% %
% Determining a given \segment is harmonious is conducted by checking a
% loop in an accumulated interleaving graph.



\PP{Generating scheduling points}
%
% After selecting harmonious \segments, generating scheduling points can
% be easily done by conducting a topological
% sort~\cite{topologicalsort}.
% %
% Since an imaginary interleaving graph is acyclic, a topological sort
% always returns a sequence of vertices (\ie, instructions) that does
% not violate a program order.
% %
% It is well known that the time complexity of a topological sort is
% $O(V+E)$. Considering that the graph is sparse, $E$ is a small value
% so the time complexity can be asymptotically considered as $O(V)$.
% %
% In this sequence, scheduling points are just instructions that the
% preemption should happen; \ie, the next instruction is executed by a
% different thread.
% %



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
