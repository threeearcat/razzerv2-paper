\section{Evaluation}
\label{s:eval}

To verify the effectiveness of our approach, we evaluate \sys in
various aspects.
%
Specifically, we 1) demonstrate the practicality of \sys by providing
newly found concurrency bugs in the Linux
kernel~(\autoref{ss:realworldbugs}),
%
2) provide comprehensive performance characteristics of \sys (\eg,
throughput and overheads)~(\autoref{ss:characteristics}) and,
%
3) compare \sys against prior concurrency fuzzing
techniques~(\autoref{ss:comparison}).

\subsection{Finding Real-world Concurrency Bugs}
\label{ss:realworldbugs}

In order to demonstrate the practicality of \sys, we run \sys to
discover concurrency bugs in the latest Linux kernel.

\begin{table*}[t]
  \input{table/newbugs.tex}
  \centering
  \caption{List of concurrency bugs newly discovered by \sys. The
    \texttt{Recurrent} column denotes that a crash was previously
    addressed but reoccurs even after its patch is applied.}
  \label{table:newbugs}
\end{table*}

\PP{Experimental setup.}
%
To discover new concurrency bugs, we evaluate \sys on a two-socket
machine equipped with Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz (40MT
cache) and 512\GB of RAM.
%
This machine provides 32 total cores and 64 total threads, and runs
Ubuntu Server 20.04.4 LTS on Linux 5.4.143 as a host operating system.
%
To build a guest kernel, we use a kernel configuration used by
\texttt{Syzkaller}~\cite{syzkaller} so that \texttt{Syzkaller} and
\sys search for bugs in similar kernel modules/subsystems.
%
We run \sys for approximately two monts on latest versions of the
Linux kernel ranging from 5.19-rc2 to 6.0-rc7.


\PP{Newly found concurrency bugs.}
%
During our evaluation, \sys discovers 83 unique crash titles including
ones that \texttt{Syzkaller} also finds. Among them, \totalbugs are
newly identified as harmful concurrency bugs as summarized in
\autoref{table:newbugs}.
%
This table shows that \sys is able to find bugs across the entire
kernel from specific device drivers~(\eg, \texttt{\#1}, and
\texttt{\#6}) to various network subsystems (\eg, \texttt{\#2},
\texttt{\#16}, and \texttt{\#17}); Since \sys is not tailored to
specific subsystems, \sys entails the \textit{generality} and is
applicable to various subsystems.

\sys is also able to find not only less-harmful bugs such as warnings
(\eg, \texttt{\#12}) but also critical bugs such as memory corruptions
(\eg, \texttt{\#2}, \texttt{\#6}, and \texttt{\#14}).
%
It is worth noting that in our evaluation, unlike previous
works~\cite{snowboard, krace} that rely on data race
detectors~\cite{kcsan, tsan}, all concurrency bugs are found by
observable and harmful incidents such as kernel panics or KASAN
reports.
%
\dr{}
We believe data race detectors and our approach are complementary in
finding concurrency bugs. We discuss this in the discussion
section~(\autoref{s:discussion}).

Interestingly, we find that many of bugs was previously found and
addressed, but they reoccur possibly because of their incomplete
fixes~\cite{learningfrommistakes}.
%
In \autoref{table:newbugs}, three that are marked in the
\texttt{Recurrent} column are cases that concurrency bugs reoccur even
after their fixes are applied.
%
These cases emphasize the importance of effective testing even after
bugs are exposed and fixed accordingly.






\subsection{Performance characteristics of \sys}
\label{ss:characteristics}

\PP{Coverage growth.}


\PP{Fuzzing throughput.}
%
\begin{table}[t]
  \small
  \centering
  \input{table/throughput}
  \caption{Fuzzing throughput (\# of exec/s) of \sys and \texttt{Syzkaller}.}
  \label{table:throughput}
\end{table}
%
All \sys's mechanisms entail the trade-off; they provide benefits in
finding concurrency bugs with a cost of additional overheads and
throughput degradation.
%
To comprehend the trade-off, we measure the fuzzing throughput of \sys
and compare it with the \texttt{Syzkaller}'s throughput.
%
Since fuzzing throughput is highly affected by initial seeds, we
measure throughput with an empty set of seed. And because both
\texttt{Syzkaller} and \sys restart VMs after an hour of fuzzing, we
run them for an hour and measure throughput in order to eliminate
noises caused by, for example, VM rebooting or kernel crashes.

\autoref{table:throughput} shows the result. As expected, \sys shows
the lower throughput than \texttt{Syzkaller}. In particular, the
\sys's throughput is about 54\% of the \texttt{Syzkaller}'s
throughput.
%
To further understand why the \sys's throughput is degraded, we
additionally measure throughput of \texttt{Syzkaller} with memory
access tracing enabled (but not making use of it).
%
As shown in the \texttt{Syzkaller-memtrace} column in
\autoref{table:throughput}, it shows the throughput similar to that of
\sys; the \texttt{Syzkaller-memtrace}'s throughput is 4.1\% higher
than the throughput of \sys.


These results indicate that the throughput of \sys is mainly caused
by the heavy instrumentation to trace memory accesses.
%
\dr{TODO:}




\PP{Per-input overhead measurment}
%
To further breakdown the 




\subsection{Comparison with prior approaches}
\label{ss:comparison}

\begin{table}[t]
  \input{table/knownbugs.tex}
  \centering
  \caption{Known CVEs caused by kernel concurrency bugs.}
  \label{table:knownbugs}
\end{table}

We compare \sys against various prior approaches to provide a .

\PP{Bug selection}
%
\autoref{table:knownbugs} represents concurrency bugs we use for the
comparison study.
%
For fair comparisons, among all kernel concurrency bugs that are used
to evaluate previous studies on kernel concurrency bugs~\cite{exprace,
  razzer, snowboard, krace}, we select ones that their exploits are
publicly available such that we can make use of them for our evaluation.
%
In particular, the exploit of
\texttt{69e16d01d1de}~\cite{snowboardbug} is not publicly available,
we successfully reproduce the concurrency bug from the description in
the Snowboard~\cite{snowboard} paper.
%
Also, even though KRace~\cite{krace} studies kernel concurrency bugs
(\ie, data races), we do not have access to concurrency bugs that the
authors use to evaluate KRace.

\PP{Overall }
%







%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
