\section{Related work}
\label{s:relwk}

% For decades, immense efforts have been made to effectively discover
% concurrency bugs in the kernel.
%
In this section, we describe prior efforts in three categories, kernel
fuzzing, controlled concurrency testing, and data race detection.


\PP{Kernel fuzzing}
%
To discover vulnerabilities in the kernel, fuzzing, specifically
coverage-guided fuzzing~\cite{syzkaller, moonshine, healer, hfl, imf,
  janus, hydra, trinity, kafl, periscope, syzvegas, ksg}, has proven
to be practical and is widely used in industrial fields.
%
% For example, Syzkaller~\cite{syzkaller}, a kernel fuzzer developed by
% Google, has found thousands of bugs through a few years of running.
%
Then, to further improve a kernel fuzzing, a number of attempts have
been made to incorporate advanced techniques~\cite{moonshine, healer, hfl},
% such as seed distillation~\cite{moonshine}, relation
% learning~\cite{healer}, and symbolic execution~\cite{hfl}.
%
or to expand the input space beyond syscalls~\cite{janus, hydra,
  periscope}.
%
Although they all achieve meaningful successes, they are limited in
exploring thread interleavings, which raises a demand for discovering
concurrency bugs in the kernel.







\PP{Controlled concurrency testing}
%
Controlled concurrnecy testing~\cite{ski, pctalgorithm, sparsernr,
  chess, nagarakatte2012multicore, abdelrasoul2017promoting,
  cai2016radius, mukherjee2020learning, schedulebounding} (abbreviated
as CCT) introduces an idea of overriding the kernel scheduler and
methodically testing thread interleavings of a \textit{given} test
scenario.
%
% In addition, they adopt various techniques to reduce the search space
% of thread interleavings such as
% %
% % preemption bounding~\cite{pctalgorithm, ski}, delay
% % bounding~\cite{delaybounding}, and
% %
% dynamic partial order reduction~\cite{dpor1, dpor2, dpor3}.
%
To the best of our knowledge, concurrency fuzzing stems from CCT
techniques with an idea of merging \textit{the test case generation}
(\ie, fuzzing) and \textit{the thread interleaving exploration} (\ie,
CCT).
%
Specifically, Razzer~\cite{razzer}, arguably the first concurrency
fuzzer, states that it is inspired by SKI~\cite{ski}, a CCT technique
aiming the kernel.
%
We believe \sys takes one step further in this direction by
incorporating informative interleaving coverage and coverage-directed
interleaving search strategy.
%
% Other concurrency fuzzers~\cite{krace, muzz, snowboard, conzzer} are
% also (at least indirectly) affected by CCT techniques as all of them
% consists of thread scheduling control mechanisms.
%
% We believe \sys takes one step further in adopting CCT into fuzzing.
% by
% answering two questions, \textit{``what is the proper interleaving
%   coverage metric''} and \textit{``how to utilize interleaving
%   coverage in searching thread interleavings''}.



\PP{Data race detection}
%
A large volume of works~\cite{pacer, datacollider, hybridchecker,
  literace, helgrind, frost, prorace, tsan, kcsan, txrace} are
proposed to detect data races, a \textit{subset} of concurrency
bugs~\cite{lkmm, linuxmemorymodel}.
%
% These works detect the occurence of two instructions that access the
% same memory address without proper synchronization or ordering.
%
In fact, data race detectors are essentially orthogonal to \sys,
thus, data race detectors can be integrated into \sys to provide a
stronger concurrency bug detection capability.
%
For example, during our evaluation, \sys can easily trigger non-data
race concurrency bugs~\cite{snowboardbug, cve20196974, cve20177533}
that cannot be detected using a data race detector (detailed in
\autoref{s:appendix:datarace}), while data race detectors can be
helpful in detecting non-memory corruption bugs such as performance
degradation.
%
% Even though we do not make use of a data race detector during our
% evaluation,
%
We believe \sys and data race detectors contribute in discovering
concurrency bugs in their own way.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "p"
%%% End:
